{"name":"Mosca","tagline":"The multi-transport MQTT broker for node.js. It supports AMQP, Redis, ZeroMQ or just MQTT.","body":"# Mosca\r\n\r\n![Mosca](https://raw.github.com/mcollina/mosca/master/mosca.png)\r\n\r\n[![Build Status](https://travis-ci.org/mcollina/mosca.png)](https://travis-ci.org/mcollina/mosca)\r\n\r\n[![NPM](https://nodei.co/npm/mosca.png)](https://nodei.co/npm/mosca/)\r\n\r\n[![NPM](https://nodei.co/npm-dl/mosca.png)](https://nodei.co/npm/mosca/)\r\n\r\nMosca is a multi-transport [MQTT](http://mqtt.org/) broker\r\nsupporting the following brokers/protocols.\r\n\r\n* [Redis](http://redis.io/), a key/value store created by [@antirez](https://github.com/antirez).\r\n* [MongoDB](http://www.mongodb.org/), a scalable, high-performance, document-oriented database.\r\n* [Mosquitto](http://mosquitto.org/) and all implementations of the [MQTT](http://mqtt.org/) protocol.\r\n* [RabbitMQ](http://www.rabbitmq.com/) and all implementations of the [AMQP](http://www.amqp.org/) protocol.\r\n* [ZeroMQ](http://www.zeromq.org/) to use Mosca in a P2P fashion.\r\n\r\n\r\nFind out more about Mosca reading the\r\n[dox generated documentation](http://mcollina.github.io/mosca/docs).\r\n\r\nIf you plan to use Mosca in production\r\n[let us know](http://twitter.com/matteocollina), we'll be more than happy to help\r\nyou getting started and solve any issue you'll find out.\r\n\r\nMosca can be used:\r\n* <a href=\"#standalone\">Standalone</a>\r\n* <a href=\"#embedded\">Embedded in another Node.js application</a>\r\n\r\n## Features\r\n\r\n* MQTT 3.1 compliant.\r\n* QoS 0 and QoS 1.\r\n* Various storage options for QoS 1 offline packets, and subscriptions.\r\n* As fast as it is possible.\r\n* Usable inside ANY other node.js app.\r\n\r\n<a name=\"standalone\"></a>\r\n## Using Mosca Standalone\r\n\r\n### Install\r\n\r\nInstall the library using [npm](http://npmjs.org/).\r\n\r\n```\r\n$ npm install mosca bunyan -g\r\n```\r\n\r\nInstall the library using git.\r\n\r\n```\r\n$ git clone git://github.com/mcollina/mosca.git\r\n$ cd mosca\r\n$ npm install\r\n```\r\n\r\n### Usage\r\n\r\nMosca offers an executable for running it standalone.\r\nRun it and connect your preferred MQTT client.\r\n\r\n```\r\n$ mosca -v | bunyan\r\n```\r\n\r\n### Configuration\r\n\r\nHere you can see the options accepted by the command line tool:\r\n\r\n```\r\n  Usage: mosca [options] [command]\r\n\r\n  Commands:\r\n\r\n    adduser <user> <pass>  Add a user to the given credentials file\r\n    rmuser <user>          Removes a user from the given credentials file\r\n    start                  start the server (optional)\r\n\r\n  Options:\r\n\r\n    -h, --help                       output usage information\r\n    -V, --version                    output the version number\r\n    -p, --port <n>                   the port to listen to\r\n    --parent-port <n>                the parent port to connect to\r\n    --parent-host <s>                the parent host to connect to\r\n    --parent-prefix <s>              the prefix to use in the parent broker\r\n    --credentials <file>             the file containing the credentials\r\n    --authorize-publish <pattern>    the pattern for publishing to topics for the added user\r\n    --authorize-subscribe <pattern>  the pattern for subscribing to topics for the added user\r\n    --key <file>                     the server's private key\r\n    --cert <file>                    the certificate issued to the server\r\n    --secure-port <n>                the TLS port to listen to\r\n    --non-secure                     start both a secure and non-secure server\r\n    -c, --config <c>                 the config file to use (override every other option)\r\n    -d, --db <path>                  the path were to store the database\r\n    -v, --verbose                    set the bunyan log to INFO\r\n    --very-verbose                   set the bunyan log to DEBUG\r\n```\r\n\r\n\r\nTo fully use mosca you need to define a configuration file where the communication\r\nbroker is defined. Here follows an example using Redis.\r\n\r\nA configuration file is structured in the following way:\r\n```javascript\r\nmodule.exports = {\r\n  port: 4883,\r\n  backend: {\r\n    type: 'redis',\r\n    redis: require('redis'),\r\n    db: 12,\r\n    port: 6379,\r\n    host: localhost\r\n  },\r\n  secure: {\r\n    keyPath: \"/path/to/key\",\r\n    certPath: \"/path/to/cert\"\r\n  }\r\n};\r\n```\r\n\r\nAd Mosca is based on Ascoltatori, [here](http://mcollina.github.com/ascoltatori#brokers) you can\r\nfind configuration examples covering Redis, MongoDB, AMQP, ZeroMQ and and MQTT brokers (e.g Mosquitto).\r\n\r\n\r\n### Authorization\r\n\r\nMosca supports user authentication through the use of a specific json file.\r\nIn order to create one run the following command.\r\n\r\n```javascript\r\n// add a user\r\n$ mosca adduser <user> <pass> --credentials ./credentials.json\r\n\r\n// add a user specifying the authorized topics\r\n$ mosca adduser myuser mypass --credentials ./credentials.json \\\r\n  --authorize-publish 'hello/*' --authorize-subscribe 'hello/*'\r\n\r\n// remove a user\r\n$ mosca rmuser myuser --credentials ./credentials.json\r\n\r\n// start Mosca with a specific set of credentials:\r\n$ mosca --credentials ./credentials.json\r\n```\r\n\r\nThe patterns are checked and validated using [Minimatch](https://github.com/isaacs/minimatch).\r\nThe credentials file can be automatically reladed by Mosca if it receives a `SIGHUP`.\r\n\r\n\r\n### Persistence\r\n\r\nThe MQTT specification requires a persistent storage for offline QoS 1\r\nsubscription that has been done by an unclean client. Mosca offers several\r\npersitance options.\r\n\r\n* [Redis](http://mcollina.github.com/mosca/docs/lib/persistence/redis.js.html)\r\n* [MongoDB](http://mcollina.github.com/mosca/docs/lib/persistence/mongo.js.html)\r\n* [LevelUp](http://mcollina.github.com/mosca/docs/lib/persistence/levelup.js.html)\r\n* [Memory](http://mcollina.github.com/mosca/docs/lib/persistence/memory.js.html)\r\n\r\nAll of them can be configured from the configuration file, under the `persistence` key.\r\nThe only exception is LevelUp, which can be specified by using the `--db` option from\r\nthe command line.\r\n\r\n\r\n<a name=\"embedded\"></a>\r\n## Embedding Mosca\r\n\r\nMosca can be used into any Node.js app. Here an example that uses MongoDB as broker.\r\n\r\n```javascript\r\nvar mosca = require('mosca')\r\n\r\nvar ascoltatore = {\r\n  type: 'mongo',\r\n  uri: 'mongodb://localhost:27017/',\r\n  db: 'mqtt',\r\n  pubsubCollection: 'ascoltatori',\r\n  mongo: {}\r\n};\r\n\r\nvar settings = {\r\n  port: 1883,\r\n  backend: ascoltatore\r\n};\r\n\r\nvar server = new mosca.Server(settings);\r\nserver.on('ready', setup);\r\n\r\n// fired when the mqtt server is ready\r\nfunction setup() {\r\n  console.log('Mosca server is up and running')\r\n}\r\n\r\n// fired when a message is published\r\nserver.on('published', function(packet, client) {\r\n  console.log('Published', packet.payload);\r\n});\r\n```\r\n\r\n\r\n### How Mosca works\r\n\r\nMosca is based on [Ascoltatori](https://github.com/mcollina/ascoltatori), a simple\r\npublish/subscribe library supporting different brokers/protocols such as Redis,\r\nMongoDB, RabbitMQ, Mosquitto, and ZeroMQ. This means that you can use any of the\r\nlisted solutions to let your MQTT client communicate with any service. Note that\r\nMosca and Ascoltatore must share the same underlying broker.\r\n\r\n#### MQTT Client Publish Flow\r\n\r\nThis is a Node.js MQTT client publishing on a topic.\r\n\r\n```javascript\r\nvar mqtt = require('mqtt')\r\n  , host = 'localhost'\r\n  , port = '1883';\r\n\r\nvar settings = {\r\n  keepalive: 1000,\r\n  protocolId: 'MQIsdp',\r\n  protocolVersion: 3,\r\n  clientId: 'client-1'\r\n}\r\n\r\n// client connection\r\nvar client = mqtt.createClient(port, host, settings);\r\n\r\n// client publishing a sample JSON\r\nclient.publish('hello/you', '{ \"hello\": \"you\" }');\r\n```\r\n\r\nThis message will be received from Mosca and any Ascoltatore who has subscribed\r\nto this topic will automatically receive the message.\r\n\r\n```javascript\r\nvar ascoltatori = require('ascoltatori');\r\nvar settings = {\r\n  type: 'mongo',\r\n  uri: 'mongodb://localhost:27017/',\r\n  db: 'mqtt',\r\n  pubsubCollection: 'ascoltatori',\r\n  mongo: {}\r\n};\r\n\r\nascoltatori.build(settings, function (ascoltatore) {\r\n  ascoltatore.subscribe('hello/*', function() {\r\n    console.log('Received message', arguments);\r\n  });\r\n});\r\n```\r\n\r\n#### MQTT Client Subscribe Flow\r\n\r\nWith the same logics, a client subscribing to Mosca for a specific topic will\r\nget notified everytime an element will be published in Ascoltatori. This is a\r\nNode.js MQTT client subscribing a topic.\r\n\r\n```javascript\r\nvar mqtt = require('mqtt')\r\n  , host = 'localhost'\r\n  , port = '1883';\r\n\r\nvar settings = {\r\n  keepalive: 1000,\r\n  protocolId: 'MQIsdp',\r\n  protocolVersion: 3,\r\n  clientId: 'client-1'\r\n}\r\n\r\n// client connection\r\nvar client = mqtt.createClient(port, host, settings);\r\n\r\n// client subscription\r\nclient.subscribe('hello/me')\r\nclient.on('message', function(topic, message) {\r\n  console.log('received', topic, message);\r\n});\r\n```\r\n\r\nWhen an Ascoltatore publishes a message to the topic, Mosca forwards it to the\r\nclient who subscribed it.\r\n\r\n```javascript\r\nvar ascoltatori = require('ascoltatori');\r\nvar settings = {\r\n  type: 'mongo',\r\n  uri: 'mongodb://localhost:27017/',\r\n  db: 'mqtt',\r\n  pubsubCollection: 'ascoltatori',\r\n  mongo: {}\r\n};\r\n\r\nascoltatori.build(settings, function (_ascoltatore) {\r\n  ascoltatore.publish('hello/me', '{ \"hello\": \"you\" }');\r\n});\r\n```\r\n\r\n\r\n### Authorizations\r\n\r\nWith Mosca you can authorize a client defining three methods.\r\n\r\n* `#authenticate`\r\n* `#authorizePublish`\r\n* `#authorizeSubscribe`\r\n\r\nThose methods can be used to restric the accessible topics for a specific clients.\r\nFollows an example where a client send a username and a password during the connection\r\nphase and where the username will be saved and used later on to verify if a specific\r\nclient can publish or subscribe for the specific user.\r\n\r\n```javascript\r\n// Accepts the connection if the username and password are valid\r\nvar authenticate = function(client, username, password, callback) {\r\n  var authorized = (username === 'alice' && password === 'secret');\r\n  if authorized client.user = username;\r\n  callback(null, authorized);\r\n}\r\n\r\n// In this case the client authorized as alice can publish to /users/alice taking\r\n// the username from the topic and verifing it is the same of the authorized user\r\nvar authorizePublish = function(client, topic, payload, callback) {\r\n  callback(null, client.user == topic.split('/')[1]);\r\n}\r\n\r\n// In this case the client authorized as alice can subscribe to /users/alice taking\r\n// the username from the topic and verifing it is the same of the authorized user\r\nvar authorizeSubscribe = function(client, topic, callback) {\r\n  callback(null, client.user == topic.split('/')[1]);\r\n}\r\n```\r\n\r\nWith this logic someone that is authorized as alice will not be able to publish to\r\nthe topic `users/bob`. Now that we have the authorizing methods we can configure mosca.\r\n\r\n```javascript\r\nvar server = new mosca.Server(settings);\r\nserver.on('ready', setup);\r\n\r\nfunction setup() {\r\n  server.authenticate = authenticate;\r\n  server.authorizePublish = authorizePublish;\r\n  server.authorizeSubscribe = authorizeSubscribe;\r\n}\r\n```\r\n\r\n### Persistence\r\n\r\nThe persistence is automatically configured when using the\r\n`mosca.Server` constructor, but it needs to be explicitly wired up.\r\nHere is the list of all supported database:\r\n\r\n* [Redis](http://mcollina.github.com/mosca/docs/lib/persistence/redis.js.html)\r\n* [MongoDB](http://mcollina.github.com/mosca/docs/lib/persistence/mongo.js.html)\r\n* [LevelUp](http://mcollina.github.com/mosca/docs/lib/persistence/levelup.js.html)\r\n* [Memory](http://mcollina.github.com/mosca/docs/lib/persistence/memory.js.html)\r\n\r\nIf you would like to see one more database, feel free to submit a\r\npull-request.\r\n\r\nThe wiring is easy:\r\n```javascript\r\n\r\nvar mosca = require(\"mosca\");\r\nvar server = new mosca.Server();\r\nvar db = new mosca.persistence.LevelUp({ path: \"/path/to/the/db\" });\r\ndb.wire(server);\r\n```\r\n\r\n### Encryption Support\r\n\r\nMosca supports encrypted communication via node's TLS implementation:\r\nhttp://nodejs.org/api/tls.html#tls_tls_ssl.\r\n\r\n```javascript\r\nvar mosca = require('mosca')\r\n\r\nvar SECURE_KEY = __dirname + '/../../test/secure/tls-key.pem';\r\nvar SECURE_CERT = __dirname + '/../../test/secure/tls-cert.pem';\r\n\r\nvar settings = {\r\n  port: 8443,\r\n  logger: {\r\n    name: \"secureExample\",\r\n    level: 40,\r\n  },\r\n  secure : { \r\n    keyPath: SECURE_KEY,\r\n    certPath: SECURE_CERT,\r\n  }\r\n};\r\nvar server = new mosca.Server(settings);\r\nserver.on('ready', setup);\r\n\r\n// fired when the mqtt server is ready\r\nfunction setup() {\r\n  console.log('Mosca server is up and running')\r\n}\r\n```\r\n\r\n## Contributing\r\n\r\nFork the repo on github and send a pull requests with topic branches.\r\nDo not forget to provide specs to your contribution.\r\n\r\n\r\n### Running specs\r\n\r\n* Fork and clone the repository\r\n* Run `npm install`\r\n* Run `npm test`\r\n\r\n\r\n## Coding guidelines\r\n\r\nFollow [felix](http://nodeguide.com/style.html) guidelines.\r\n\r\n\r\n## Feedback\r\n\r\nUse the [issue tracker](http://github.com/mcollina/mosca/issues) for bugs.\r\n[Tweet](http://twitter.com/matteocollina) us for any idea that can improve the project.\r\n\r\n\r\n## Links\r\n\r\n* [GIT Repository](http://github.com/mcollina/mosca)\r\n* [Mosca Documentation](http://mcollina.github.io/mosca/docs)\r\n* [Ascoltatori](http://github.com/mcollina/ascoltatori)\r\n* [MQTT protocol](http://mqtt.org)\r\n* [MQTT.js](http://github.com/adamvr/MQTT.js)\r\n\r\n\r\n## Authors\r\n\r\n[Matteo Collina](http://twitter.com/matteocollina)\r\n\r\n## Contributors\r\n\r\n<table><tbody>\r\n<tr><th align=\"left\">David Halls</th><td><a\r\nhref=\"https://github.com/davedoesdev\">GitHub/davedoesdev</a></td>\r\n</tr>\r\n<tr><th align=\"left\">Andrea Reginato</th><td><a\r\nhref=\"https://github.com/andreareginato\">GitHub/andreareginato</a></td>\r\n</tr>\r\n<tr><th align=\"left\">Chris Wiggins</th><td><a\r\nhref=\"https://github.com/chriswiggins\">GitHub/chriswiggins</a></td>\r\n</tbody></table>\r\n\r\n## LICENSE - \"MIT License\"\r\n\r\nCopyright (c) 2013 Matteo Collina, http://matteocollina.com\r\n\r\nPermission is hereby granted, free of charge, to any person\r\nobtaining a copy of this software and associated documentation\r\nfiles (the \"Software\"), to deal in the Software without\r\nrestriction, including without limitation the rights to use,\r\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the\r\nSoftware is furnished to do so, subject to the following\r\nconditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\nOTHER DEALINGS IN THE SOFTWARE.\r\n","google":"UA-20777444-5","note":"Don't delete this file! It's used internally to help with page regeneration."}